---

layout: default

style: |
    .big-code {
        font-size: 14px;
    }


---

# ![](themes/yandex2/images/logo-{{ site.presentation.lang }}.svg){:.logo}

## {{ site.presentation.title }}
{:.title}

### ![](themes/yandex2/images/title-logo-{{ site.presentation.lang }}.svg){{ site.presentation.service }}

<div class="authors">
{% if site.author %}
<p>{{ site.author.name }}{% if site.author.position %}, {{ site.author.position }}{% endif %}</p>
{% endif %}

{% if site.author2 %}
<p>{{ site.author2.name }}{% if site.author2.position %}, {{ site.author2.position }}{% endif %}</p>
{% endif %}

</div>

## Небольшой план

1. Вводная
2. Бизнес-сущности
3. Как это было раньше
4. Подход в стиле redux
5. Наш подход с виджетами

## Вводная
{:.section}

## Продаем топоры

У нас есть топоры разных моделей, цен и несколько партнеров-поставщиков

## ![img](pictures/first-design.png)
{: .slide .cover first-design.png)

## Back to 2000

Как бы мы это сделали в середине прошлого десятилетия?

1. Какой-нибудь декларативный шаблонизатор (f.g. XSLT)
2. Древовидный формат данных

## Представим «стейт»

или то, что мы отдаем шаблонизатору для первоначального рендеринга


## Пример данных
{:.fullscreen}

```js
[{
    title: 'Axe 2000',
    offers: [{
        price: 500,
        shop: {
            title: 'Тверские топоры'
        }
    }, {
        price: 200,
        shop: {
            title: 'Новгородские топоры'
        }
    }]
}];
```

## Этого достаточно, чтобы отрисовать страницу

Но тут есть проблемы:

1. Они не переиспользуются, их структура ничем не гарантируется
2. К такому коду нельзя написать надежный селектор
3. Эти данные описывают макет, а не предметную область
4. С новым макетом или страницей придется изобретать новый формат

## Проектируем нормально

**О чем следовало подумать в первую очередь?**

1. Какие сущности могут описать предметную область?
2. Как описать связи между этими сущностями?
3. Как их хранить и как с ними работать?

## Выделим бизнес-сущности

1. Модель топора (model)
2. Конкретное предложение (offer)
3. Магазин-партнер (shop)

![](pictures/entities.png)
{:.image-right}

## Пометим сущности полем entity

~~~ javascript
[{
    entity: 'model',
    offers: [{
        entity: 'offer',
        shop: {
            entity: 'shop',
        }
    }]
}];
~~~

## Почему стало лучшие?

1. Работая с бизнес-сущностями, мы можем поддерживать контракт
2. Сущности остаются прежними вне зависимости от макета
3. Легко и понятно, как написать селекторы, на что завязаться

## Однако есть и другие проблемы

1. Дублирование данных
2. Нет единого источника истины
3. Такие данные сложно изменять

## Пример с дублированием данных
{:.big-code}

~~~ javascript
[{
    entity: 'offer',
    shop: {
        entity: 'shop',
        title: 'Тверские топоры'
    }
}, {
    entity: 'offer',
    shop: {
        entity: 'shop',
        title: 'Тверские топоры'
    }
}];
~~~

## Наше время
{:.section}

## Redux и normalizr во фронтенде

Что это значит?

1. Redux подталкивает нас к нормализации
2. Нет дублирования в рамках одного стора
3. Возможно сделать единый источник истины для всего приложения

## А что такое normalizr?

Небольшая библиотека для конвертации вложенных данных в нормализованные на основе описанной схемы

https://github.com/paularmstrong/normalizr

## Пример нормализованных данных
{:.fullscreen}
{:.big-code}

~~~ javascript
{
    items: [{entity: 'offer', id: 1}, {entity: 'offer', id: 2}],
    entities: {
        offer: {
            "1": {
                entity: 'offer',
                shop: "shopId1",
            },
        },
        shop: {
           "shopId1": {
                entity: 'shop',
            },
        },
    },
}
~~~

## Итого

* Наши данные нормализованы и дедуплецированы
* Есть единый источник истины (redux store)
* Исходя из предыдущих пунктов, эти двнные удобно модифицировать

## Немного усложним задачу

Теперь менеджеры магазина хотят:

* Размещать произвольное количество наборов топоров в любой последовательности
* Если возникает ошибка в одном из наборов, остальные подгружаются как есть
* Первые наборы топоров должны показываться сразу, не ожидая прогрузки всех остальных

## ![img](pictures/second-design.png)
{: .slide .cover .w  .center }

## Что это значит с точки зрения разработки?

* Каждый набор топоров запрашивает данные у бекенда отдельно
* Для переиспользования логика получения данных инкапсулирована в компоненте
* Не смотря на две особенности выше, нужно как-то дедуплецировать данные между наборами

... **Другими словами, набор топоров становится виджетом**

## Что такое виджеты?

Это независимая часть приложения, которая:

* сама знает, как получить и отрисовать данные
* не влияет на другие виджеты
* является error-boundary (границой ошибок)
* работает полностью независимо от других виджетов.

## Звучит здорово, однако...

... как же дедупликация данных?

... как обеспечить независимость виджетов в store?

## Ответ

1. Разделение данных на данные виджета и коллекции
2. Своя версия connect

## Коллекции

1. Неупорядоченное хранилище сущностей по ключу
2. Доступно всем виджетам сразу

## Данные виджета

1. Ключи для коллекций с сохранением нужного порядка
2. Данные, которые не являются сущностями и принадлежат именно этому виджету

## Пример
{:.fullscreen}

```js
{
    collections: {
	  offer: {1: {price: 500}, 2: {price: 200}, 3: {price: 600}},
      shops: {"shop1": {title: 'Новгородские топоры'}}
	}
	widgets: {
	  "axesPack1": {
	     offerIds: [1, 2, 3, 2],
	   },
	  "axesPack2": {
	    offerIds: [3, 3, 4, 5],
	  },
	},
}
```

## Connect

Чтобы гарантировать принцип независимости, используем свою обертку над connect

1. Ограничивает mapStateToProps коллекциями и данными виджета
2. В остальном работает точно так же, как и обычный connect

## Если визуализировать
## ![img](pictures/widgets-state.jpeg)

## Хорошо, а что подгрузкой данных?

1. Виджеты сами знают, как сделать запрос за дополнительными данными
2. Виджеты сами могут обновить коллекции (это просто редюсер)

## Подведем итог

1. Всегда следует не адаптировать данные под макеты, а описывать бизнес-сущности
2. Redux позволяет дедуплецировать и легко обновлять данные
3. На его основе можно удобно сконструировать свою виджетную систему

## PS

Детальный рассказ про нашу виджетную систему от Паши Павелко:

<a href="http://www.highload.ru/siberia/2018/abstracts/3682">http://www.highload.ru/siberia/2018/abstracts/3682</a>

## Контакты 
{:.contacts}

{% if site.author %}

<figure markdown="1">

### {{ site.author.name }}

{% if site.author.position %}
{{ site.author.position }}
{% endif %}

</figure>

{% endif %}

{% if site.author2 %}

<figure markdown="1">

### {{ site.author2.name }}

{% if site.author2.position %}
{{ site.author2.position }}
{% endif %}

</figure>

{% endif %}

<!-- разделитель контактов -->
-------

<!-- left -->
- {:.telegram}imalyavin
- {:.mail}ilya.m32@yandex.ru

<!-- 

- {:.mail}author@yandex-team.ru
- {:.phone}+7-999-888-7766
- {:.github}author
- {:.bitbucket}author
- {:.twitter}@author
- {:.telegram}author
- {:.skype}author
- {:.instagram}author
- {:.facebook}author
- {:.vk}@author
- {:.ok}@author

-->
