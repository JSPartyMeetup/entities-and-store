---

layout: yandex2

style: |
    /* собственные стили можно писать здесь!! */
    .center-align {
        text-align: center;
    }


---

# ![](themes/yandex2/images/logo-{{ site.presentation.lang }}.svg){:.logo}

## {{ site.presentation.title }}
{:.title}

### ![](themes/yandex2/images/title-logo-{{ site.presentation.lang }}.svg){{ site.presentation.service }}

<div class="authors">
{% if site.author %}
<p>{{ site.author.name }}{% if site.author.position %}, {{ site.author.position }}{% endif %}</p>
{% endif %}

{% if site.author2 %}
<p>{{ site.author2.name }}{% if site.author2.position %}, {{ site.author2.position }}{% endif %}</p>
{% endif %}

</div>

## Небольшой план

1. {:.next} Вводная
2. {:.next} Бизнес-сущности
3. {:.next} Как это было раньше
4. {:.next} Подход в стиле redux
5. {:.next} Наш подход с виджетами

## Вводная


## Продаем топоры

У нас есть топоры разных моделей, цен и несколько партнеров-поставщиков

## ![](pictures/first-design.png)
{: .slide .cover first-design.png)

## Back to 2000

Как бы мы это сделали в середине прошлого десятилетия?

1. Какой-нибудь декларативный шаблонизатор (f.g. XSLT)
2. Древовидный формат данных

## Представим «стор»

или то, что мы отдаем шаблонизатору для первоначального рендеринга


## Пример данных
{:.fullscreen}
```js
[{
    title: 'Axe 2000',
    offers: [{
        price: 500,
        shop: {
            title: 'Тверские топоры'
        }
    }, {
        price: 200,
        shop: {
            title: 'Новгородские топоры'
        }
    }]
}];
```

## Этого достаточно, чтобы отрисовать страницу

Но тут есть проблемы:

1. {:.next}Они не переиспользуются, их структура ничем не гарантируется
2. {:.next}К такому коду нельзя написать надежный селектор
3. {:.next}Эти данные описывают макет, а не предметную область
4. {:.next}С новым макетом или страницей придется изобретать новый формат

## Проектируем нормально

**О чем следовало подумать в первую очередь?**

1. {:.next}Какие сущности могут описать предметную область?
2. {:.next}Как описать связи между этими сущностями?
3. {:.next}Как их хранить и как с ними работать?

## Выделим очевидное

1. {:.next}Модель топора (model)
2. {:.next}Конкретное предложение (offer)
3. {:.next}Магазин-партнер (shop)

## ![](pictures/entities.png)
{: .slide .cover .w  .center .center-align}

## Тут пример кода, а этот заголовок все равно не видно

~~~ javascript
[{
    entity: 'model',
    offers: [{
        entity: 'offer',
        shop: {
            entity: 'shop',
        }
    }]
}];
~~~

## Почему стало лучшие?

1. {:.next}Работая с бизнес-сущностями, мы можем поддерживать контракт
2. {:.next}Сущности остаются прежними вне зависимости от макета
3. {:.next}Легко и понятно, как написать селекторы, на что завязаться

## Однако есть и другие проблемы

1. {:.next}Дублирование данных
2. {:.next}Нет единого источника истины
3. {:.next}Такие данные сложно изменять

## Пример с дублированием данных
{:.big-code}

~~~ javascript
[{
    entity: 'offer',
    shop: {
        entity: 'shop',
        title: 'Тверские топоры'
    }
}, {
    entity: 'offer',
    shop: {
        entity: 'shop',
        title: 'Тверские топоры'
    }
}];
~~~

## Вернемся в наше время: Redux и normalizr во фронтенде

Что это значит?

1. {:.next}Redux by design подталкивает нас к нормализации
2. {:.next}Нет дублирования в рамках одного стора
3. {:.next}Возможно сделать единый источник истины для всего приложения

## А что такое redux и store вообще?
-- ТУТ ОБЪЯСНЯЮЩАЯ КАРТИНКА --

## А что такое normalizr?
-- ТУТ ОПИСАНИЕ нормалайзера --

## Пример нормализованных данных
{:.fullscreen}
{:.big-code}

```js
{
    items: [{entity: 'offer', id: 1}],
    entities: {
        offer: {
            "1": {
                entity: 'offer',
                id: 1,
                shop: "shopId1",
            },
        },
        shop: {
           "shopId1": {
                entity: 'shop',
                id: "shopId1",
            },
        },
    },
}
```

## Немного усложним задачу

Теперь менеджеры магазина хотят:

* {:.next} Размещать произвольное количество наборов топоров в любой последовательности
* {:.next} Если возникает ошибка в одном из наборов, остальные подгружаются как есть
* {:.next} Первые наборы топоров должны показываться сразу, не ожидая прогрузки всех остальных

## Иллюстрация множественных каруселей

## ![](pictures/second-design.png)
{: .slide .cover .w  .center }

## Что это значит с точки зрения разработки?

* {:.next} Каждый набор топоров запрашивает данные у бекенда отдельно
* {:.next} Для переиспользования логика получения данных инкапсулирована в компоненте
* {:.next} Не смотря на две особенности выше, нужно как-то дедуплецировать данные между наборами

... **Другими словами, набор топоров становится виджетом**

## Что такое виджеты?

Это независимая часть приложения, которая:

* {:.next}сама знает, как получить и отрисовать данные
* {:.next}не влияет на другие виджеты
* {:.next}является error-boundary (границой ошибок)
* {:.next}работает полностью независимо от других виджетов.

## Звучит здорово, однако...

... как же дедупликация данных?

... как обеспечить независимость виджетов в store?

## Ответ

1. {:.next}Разделение данных на данные виджета и коллекции
2. {:.next}Своя версия connect

## Коллекции

1. {:.next}Неупорядоченное хранилище сущностей по ключу
2. {:.next}Доступно всем виджетам сразу

## Данные виджета

1. {:.next}Ключи для коллекций с сохранением нужного порядка
2. {:.next}Данные, которые не являются сущностями и принадлежат именно этому виджету

## Пример
{:.fullscreen}

```js
{
    collections: {
	  offer: {1: {...}, 2: {...}},
	}
	widgets: {
	  "carousel1": {
	     offerIds: [1, 2],
	   },
	  "carousel2": {
	    offerIds: [2, 3],
	  },
	},
}
```

## Connect

Чтобы гарантировать принцип независимости, используем свою обертку над connect

1. {:.next}Ограничивает mapStateToProps коллекциями и данными виджета
2. {:.next}В остальном работает точно так же, как и обычный connect

## Хорошо, а что подгрузкой данных?

1. {:.next}Виджеты сами знают, как сделать запрос за дополнительными данными
2. {:.next}Виджеты сами могут обновить коллекции (это просто редюсер)

## Подведем итог

... * Всегда следует не адаптировать данные под макеты, а описывать бизнес-сущности
... * Redux позволяет дедуплецировать и легко обновлять данные
... * На его основе можно удобно сконструировать свою виджетную систему

## PS

Детальный рассказ про нашу виджетную систему от Паши Павелко:

http://www.highload.ru/siberia/2018/abstracts/3682

## Контакты 
{:.contacts}

{% if site.author %}

<figure markdown="1">

### {{ site.author.name }}

{% if site.author.position %}
{{ site.author.position }}
{% endif %}

</figure>

{% endif %}

{% if site.author2 %}

<figure markdown="1">

### {{ site.author2.name }}

{% if site.author2.position %}
{{ site.author2.position }}
{% endif %}

</figure>

{% endif %}

<!-- разделитель контактов -->
-------

<!-- left -->
- {:.telegram}imalyavin
- {:.mail}ilya.m32@yandex.ru

<!-- 

- {:.mail}author@yandex-team.ru
- {:.phone}+7-999-888-7766
- {:.github}author
- {:.bitbucket}author
- {:.twitter}@author
- {:.telegram}author
- {:.skype}author
- {:.instagram}author
- {:.facebook}author
- {:.vk}@author
- {:.ok}@author

-->
