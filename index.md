---

layout: yandex2

style: |
    /* собственные стили можно писать здесь!! */


---

# ![](themes/yandex2/images/logo-{{ site.presentation.lang }}.svg){:.logo}

## {{ site.presentation.title }}
{:.title}

### ![](themes/yandex2/images/title-logo-{{ site.presentation.lang }}.svg){{ site.presentation.service }}

<div class="authors">
{% if site.author %}
<p>{{ site.author.name }}{% if site.author.position %}, {{ site.author.position }}{% endif %}</p>
{% endif %}

{% if site.author2 %}
<p>{{ site.author2.name }}{% if site.author2.position %}, {{ site.author2.position }}{% endif %}</p>
{% endif %}

</div>

## Карта

1. {:.next} Вводная
2. {:.next} Бизнес-сущности
3. {:.next} Как это было раньше
4. {:.next} Подход в стиле redux
5. {:.next} Наш подход с виджетами

## Небольшая вводная


## Продаем топоры

У нас есть топоры разных моделей, цен и несколько партнеров-поставщиков

## Эскиз для наглядности
{:.fullscreen}

![](pictures/first-design.png)

## Back to 2000

Как бы мы это сделали в середине прошлого десятилетия?

1. Какой-нибудь декларативный шаблонизатор (f.g. XSLT)
2. Древовидный формат данных

## Представим «стор»

или то, что мы отдаем шаблонизатору для первоначального рендеринга


## Пример данных
{:.fullscreen}
```js
[{
    title: 'Axe 2000',
    offers: [{
        price: 500,
        shop: {
            title: 'Тверские топоры'
        }
    }, {
        price: 200,
        shop: {
            title: 'Новгородские топоры'
        }
    }]
}];
```

## Этого достаточно, чтобы отрисовать страницу

Но тут есть проблемы:

1. {:.next}К такому коду нельзя написать надежный селектор
2. {:.next}Эти данные описывают макет, а не предметную область
3. {:.next}Они не переиспользуются, их структура ничем не гарантируется
4. {:.next}С новым макетом придется изобретать новый формат

## Проектируем нормально

**О чем следует подумать при проектировании стейта для магазина в первую очередь?**

1. {:.next}Какие сущности могут описать предметную область?
2. {:.next}Как их хранить и как с ними работать?

## Выделим очевидное

1. {:.next}Модель топора (model)
2. {:.next}Конкретное предложение (offer)
3. {:.next}Магазин-партнер (shop)

## Тут пример кода, а этот заголовок все равно не видно
{:.fullscreen}
{:.big-code}

~~~ javascript
[{
    entity: 'model',
    title: 'Axe 2000',
    offers: [{
        entity: 'offer',
        price: 500,
        shop: {
            entity: 'shop',
            title: 'Тверские топоры'
        }
    }, {
        entity: 'offer',
        price: 200,
        shop: {
            entity: 'shop',
            title: 'Новгородские топоры'
        }
    }]
}];
~~~

## Стало сильно лучше

1. {:.next}Работая с бизнес-сущностями, мы можем поддерживать контракт
2. {:.next}Сущности остаются прежними вне зависимости от макета
3. {:.next}Легко и понятно, как написать селекторы, на что завязаться

## Однако есть и другие проблемы

1. {:.next}Дублирование данных
2. {:.next}Нет единого источника истины
3. {:.next}Такие данные сложно изменять

## Пример с дублированием данных
{:.fullscreen}
{:.big-code}

~~~ javascript
[{
    entity: 'offer',
    price: 500,
    title: "Топор Витязь",
    shop: {
        entity: 'shop',
        title: 'Тверские топоры'
    }
}, {
    entity: 'offer',
    price: 400,
    title: "Топор Витязь",
    shop: {
        entity: 'shop',
        title: 'Новгородские топоры'
    }
}];
~~~

## Вернемся в наше время: Redux и normalizr во фронтенде

Что это значит?

1. {:.next}Redux by design подталкивает нас к нормализации
2. {:.next}Нет дублирования в рамках одного стора
3. {:.next}Возможно сделать единый источник истины для всего приложения

## Пример нормализованных данных
{:.fullscreen}
{:.big-code}

```js
{
    items: [{entity: 'offer', id: 1}],
    entities: {
        offer: {
            "1": {
                entity: 'offer',
                id: 1,
                shop: "shopId1",
            },
        },
        shop: {
           "shopId1": {
                entity: 'shop',
                title: 'Тверские топоры',
                id: "shopId1",
            },
        },
    },
}
```

## Немного усложним задачу

Теперь менеджеры магазина хотят:

1. Размещать произвольное количество каруселей с топорами в любой последовательности
2. Первые карусели должны показываться сразу, не ожидая прогрузки всех остальных

## Что поможет?

## Виджеты!

Независимая часть приложения, которая:

* {:.next}сама знает, как получить и отрисовать данные
* {:.next}не влияет на другие виджеты
* {:.next}является error-boundary

работает полностью независимо от других виджетов.

## Звучит здорово, однако...

... как же дедупликация данных?

... как обеспечить независимость виджетов в store?

## Ответ

1. {:.next}Разделение данных на данные виджета и коллекции
2. {:.next}Своя версия connect

## Коллекции

1. {:.next}Неупорядоченное хранилище сущностей по ключу
2. {:.next}Доступно всем виджетам сразу

## Данные виджета

1. {:.next}Ключи для коллекций с сохранением нужного порядка
2. {:.next}Данные, которые не являются сущностями и принадлежат именно этому виджету

## Пример
{:.fullscreen}

```js
{
    collections: {
	  offer: {1: {...}, 2: {...}},
	}
	widgets: {
	  "carousel1": {
	     offerIds: [1, 2],
	   },
	  "carousel2": {
	    offerIds: [2, 3],
	  },
	},
}
```

## Connect

Чтобы гарантировать принцип независимости, используем свою обертку над connect

1. {:.next}Ограничивает mapStateToProps коллекциями и данными виджета
2. {:.next}В остальном работает точно так же, как и обычный connect

## Хорошо, а что подгрузкой данных?

1. {:.next}Виджеты сами знают, как сделать запрос за дополнительными данными
2. {:.next}Виджеты сами могут обновить коллекции (это просто редюсер)

## Все ли так хорошо?...

... Нужно быть предельно аккуратными с сущностями
... если поля могут отличаться в зависимости от контекста, то это отдельная сущность

## Пример на топорах

Мы хотим брать разную коммиссию в зависимости от места показа

## Кодд
{:.fullscreen}

```js
// First
{
    entity: 'offer',
    color: 'red',
    price: 500,
    partnerUrl: '//tverskie-topori.com?comission=cheap
},

// Second
{
    entity: 'offer',
    color: 'red',
    price: 500,
    partnerUrl: '//tverskie-topori.com?comission=expensive
},
```

## Пересмотрим сущности

... Теперь мы отрисовываем не предложения, а места показа
... А уже конкретное место показа знает, какое это предложение

## Code
{:.fullscreen}

```js
{
    collections: {
	  offer: {1: {...}, 2: {...}},
      showPlace: {"1_cheap": {entity: "showPlace", offerId: 1}}
	}
	widgets: {
	  "carousel1": {
	     showPlaceId: ["1_cheap"],
	   },
	},
}
```

## PS

Виджеты могут принести еще больше пользы

* Прогрессивная отдача
* Вложенность виджетов
* Виджет как микросервис
* И так далеее


## Контакты 
{:.contacts}

{% if site.author %}

<figure markdown="1">

### {{ site.author.name }}

{% if site.author.position %}
{{ site.author.position }}
{% endif %}

</figure>

{% endif %}

{% if site.author2 %}

<figure markdown="1">

### {{ site.author2.name }}

{% if site.author2.position %}
{{ site.author2.position }}
{% endif %}

</figure>

{% endif %}

<!-- разделитель контактов -->
-------

<!-- left -->
- {:.telegram}imalyavin
- {:.mail}ilya.m32@yandex.ru

<!-- 

- {:.mail}author@yandex-team.ru
- {:.phone}+7-999-888-7766
- {:.github}author
- {:.bitbucket}author
- {:.twitter}@author
- {:.telegram}author
- {:.skype}author
- {:.instagram}author
- {:.facebook}author
- {:.vk}@author
- {:.ok}@author

-->
